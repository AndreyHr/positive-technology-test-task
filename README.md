# Positive-technologies-fibbonachi
Тестовое для PT.
Если кому-нибудь поможет сэкономить пару часов(как минимум гуглеж StructureMap и MassTransit Bus может столько занять, если до этого с ними не сталкивались) - уже буду рад + из комментария более понятны требования к задачи(в самом задании сильно размыты)


Тестовое задание, Positive Technology числа фиббоначи, оценочное время выполнения - 6 часов:

Задание кандидату на вакансию разработчика C#

Два приложения общаются друг с другом через транспорты, реализуя расчет чисел Фибоначчи.

Логика расчета одной последовательности такая:

1. Первое инициализирует расчет.

2. Первое отправляет второму N_I

3. Второе вычисляет N_(I – 1) + N_I и шлет обратно

4. Логика повторяется симметрично.

5. И так до остановки приложений.

Особенности:

1. Первое приложение при старте получает параметр – целое число, сколько асинхронных расчетов начать.

2. Все расчеты идут параллельно.

3. Передача данных от 1 к 2 идет через Rest WebApi

4. Передача данных от 2 к 1 идет посредством MessageBus.

5. Язык C#, среда MS .NET Framework версии от 4.0.

Рекомендуемые технологии: · ASP.NET WebApi

· RestSharp

· MassTransit Bus

· Log4Net

· StructureMap


### Комментарий к решению(был отправлен вместе с заданием):

Времени затратил больше 6 часов, т.к. предложенные технологиии раньше не использовал(StructureMap, Mass Transit, RestSharp), соответственно best practices для них не знаю, может быть не все хорошо.
Простое решение  логичнее было сделать на webapi проекте и консольном(в каждом определить соответсвующие методы отправки\приема), но мне было интересно попробовать универсальное решение - соответсвенно отправка\прием для каждого способа имеют один интерфейс, и, вынеся конфигурацию DI и параметр, должно ли приложение инициировать расчет, можно использовать одно консольное приложение как в первой так и во второй роли.
 
 Возможные проблемы(на которые было жалко тратить время, либо сочел неважным):
1) Фиббоначи считается в пределах лонга - т.к. решил что ресерч расчета бесконечно большой последовательности тянет на отдельную задачу(а bigInt тоже имеет ограничения) для наглядности в коде Sleep(500), чтобы не выводилось сразу все
2) Фиббоначи расчитывается на основе предыдущих сохраненных значений(у меня в листе хранится, но можно последнее хранить), с отдельными списками для каждого параллельного расчета(у каждого свой гуид), доступ обеспечивается через ConcurentDictionary. Возможно есть математические способы считать только на основе текущего(без полного расчета), но я их не знаю и не искал
3) Над именами переменных и классов долго не думал, не все может быть корректно, также какие-то классы находятся в одном файле, в идеале их нужно разносить
4) Когда первое приложение превышает лонг- второе не узнает об этом, реализуется отправкой специального сообщения.


### Причины по которым не было принято:

1) ConcurrentDictionary используется некорректно
2) Не используется BigInt
3) Приложение зачем-то хранит ВСЕ вычисленные значения для когда-либо начатых вычислений. То есть не текущее число, а список всех до этого посчитанных чисел. Притом для каждого нового потока этот список дублируется.
4) Не выделена абстракция для вычислений (класс Calculator по сути статический)
5) Не понятно, зачем нужен велосипед public interface IObserver, когда есть встроенный IObservable и накрученный вокруг него Rx
6) public class Message можно переиспользовать и в WebApi
7) Не понравилась абстракция public interface IsettingsProvider. Настройки остаются нетипизированными, проверка происходит только при использовании настройки. Притом код обработки ошибок вообще странный. NullReference то почему? 

     if (setting == null)
            {
                Logger.Log.Fatal($"setting {name} doesn't exist");
                throw new NullReferenceException();
            }



